# Context Guardian CLI

## What This Is

The **Context Guardian CLI** is the main command-line tool that developers interact with. It orchestrates the entire workflow: analyzing projects, calling the API, and generating the `.guardian.md` playbook file.

## How It Fits Into The Bigger Picture

Context Guardian's architecture:

1. **CLI** (this package) â†’ User-facing tool, orchestrates everything
2. **Dependency Parser** â†’ Imported as a module, extracts dependencies
3. **API** â†’ Called by CLI to get version-specific best practices
4. **Database** â†’ Queried by API for rules
5. **Playbook** â†’ Generated by CLI, consumed by AI assistants

**This is the entry point.** Users run `guardian init` and everything else happens automatically.

## Installation

### For Development

```bash
npm install
npm run build
npm link  # Makes 'guardian' command available globally
```

### For End Users (when published)

```bash
npm install -g context-guardian
```

## Usage

### Initialize a project

```bash
guardian init
```

Creates a `.guardian.md` file in the current directory with version-aware best practices.

### Update the playbook

```bash
guardian sync
```

Re-analyzes dependencies and updates `.guardian.md` when you add/update packages.

### Validate playbook

```bash
guardian validate
```

Checks if the playbook is up-to-date. Use `--strict` to exit with error if outdated.

## Commands

| Command | Description | Options |
|---------|-------------|---------|
| `guardian init` | Initialize Context Guardian | `--force`, `--offline`, `-v` |
| `guardian sync` | Update playbook | `-v` |
| `guardian validate` | Check if playbook is current | `--strict` |

## Configuration

Context Guardian can be configured via environment variables:

```bash
export GUARDIAN_API_URL="https://api.contextguardian.dev"
export GUARDIAN_API_KEY="your-api-key"  # Optional, for Pro/Team tiers
export GUARDIAN_OFFLINE="true"          # Use offline mode
export GUARDIAN_VERBOSE="true"          # Enable debug logging
```

## Project Structure

```
context-guardian-cli/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ cli.ts                    # Main CLI entry point
â”‚   â”œâ”€â”€ index.ts                  # Programmatic API exports
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ init.ts               # Init command
â”‚   â”‚   â”œâ”€â”€ sync.ts               # Sync command
â”‚   â”‚   â””â”€â”€ validate.ts           # Validate command
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ config.ts             # Configuration management
â”‚   â”‚   â”œâ”€â”€ logger.ts             # Colored logging
â”‚   â”‚   â”œâ”€â”€ api-client.ts         # API communication
â”‚   â”‚   â””â”€â”€ playbook-generator.ts # Markdown formatter
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts              # TypeScript types
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ playbook-generator.test.ts
â””â”€â”€ package.json
```

## Development

### Build

```bash
npm run build
```

Compiles TypeScript to `dist/` directory.

### Run Tests

```bash
npm test
```

### Test Locally

After building, you can test the CLI:

```bash
node dist/cli.js init
```

Or if you've run `npm link`:

```bash
guardian init
```

## Key Design Decisions

### 1. Commander.js for CLI Framework

We use Commander.js because it's:
- Industry standard for Node.js CLIs
- Simple, declarative API
- Automatic help generation
- Supports subcommands and options

### 2. Modular Command Structure

Each command is in its own file (`commands/init.ts`, etc.) for:
- Easy testing
- Clear separation of concerns
- Simple to add new commands

### 3. Ora for Spinners

We use Ora for progress indication because AI analysis can take a few seconds. Users need feedback that something is happening.

### 4. Chalk for Colors

Color-coded output improves UX:
- ðŸ”µ Blue = Info
- ðŸŸ¢ Green = Success
- ðŸŸ¡ Yellow = Warning
- ðŸ”´ Red = Error

### 5. Programmatic API

The CLI exports a programmatic API (`src/index.ts`) so other tools can use Context Guardian as a library, not just a CLI.

## Integration Points

### With Dependency Parser

```typescript
// This will be implemented when integrating modules
import { analyzeDependencies } from '@context-guardian/dependency-parser';

const manifest = analyzeDependencies(process.cwd());
// Send manifest to API
```

### With API

```typescript
import { ApiClient } from './utils/api-client';

const client = new ApiClient();
const response = await client.generatePlaybook(payload);
```

### With Playbook Generator

```typescript
import { PlaybookGenerator } from './utils/playbook-generator';

const generator = new PlaybookGenerator();
generator.generate(response, projectPath);
```

## Current Status (MVP Scaffold)

This is a **scaffold** with placeholder implementations. The following need to be integrated:

- [ ] Import and use Dependency Parser module
- [ ] Implement actual API calls (currently mocked)
- [ ] Add offline mode with SQLite fallback
- [ ] Implement change detection for `sync` command
- [ ] Add caching to avoid redundant API calls

These will be completed when all modules are ready for integration.

## Reference Documentation

For full context on the project architecture and strategy, see:
- `/home/ubuntu/phase-0_planning/context_guardian_project_plan.md`
- `/home/ubuntu/phase-0_planning/product_architecture.md`

## Next Steps

See `CLAUDE_START-HERE.md` for development setup instructions.
